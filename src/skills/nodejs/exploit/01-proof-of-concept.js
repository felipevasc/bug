#!/usr/bin/env node
'use strict';

/**
 * @skill: nodejs/exploit/proof-of-concept
 * @inputs: target[, out-dir, scope-file, rate, timeout, allow-exploit]
 * @outputs: finding|note
 * @tools: curl, nuclei
 */

const path = require('path');
const { loadScopeFile, targetInScope } = require('../../../lib/scope');
const { parseCommonArgs, emitJsonl, which, runCmdCapture, writeEvidence, ensureDir } = require('../../../lib/skill-utils');

const STAGE = 'exploit';
const SOURCE = 'src/skills/nodejs/exploit/01-proof-of-concept.js';

function safeOutDir(outDir, runTs) {
  const root = outDir || process.env.OUT_DIR || path.resolve('data', 'runs', runTs || 'run');
  const dir = path.join(root, 'evidence', 'exploit', 'poc');
  ensureDir(dir);
  return dir;
}

function exploitAllowed(allowExploit) {
  return Boolean(allowExploit) && String(process.env.CONFIRM || '') === 'arrocha!';
}

async function run({ target, emit, outDir, scopeFile, timeout, allowExploit, runTs }) {
  const scope = loadScopeFile(scopeFile);
  if (!targetInScope(target, scope.entries)) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'scope',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [`out_of_scope: ${target}`],
      data: { reason: 'target not in scope (blocked)' },
      source: SOURCE
    });
    return;
  }

  const evDir = safeOutDir(outDir, runTs);
  const maxSecs = Number(timeout || 20);

  // Safe-by-default: check for common accidental exposures (simple GET/HEAD).
  const baseUrls = [`https://${target}`, `http://${target}`];
  const paths = ['/.git/HEAD', '/.env', '/.DS_Store', '/robots.txt'];
  const hits = [];

  if (which('curl')) {
    for (const base of baseUrls) {
      for (const p of paths) {
        // eslint-disable-next-line no-await-in-loop
        const res = await runCmdCapture('bash', ['-lc', `timeout ${maxSecs}s curl -k -s -o /dev/null -w '%{http_code}' ${JSON.stringify(base + p)} || true`]);
        const code = String(res.stdout || '').trim();
        if (code && code !== '000' && code !== '404') hits.push({ url: base + p, code });
      }
    }
  } else {
    emitJsonl(emit, {
      type: 'note',
      tool: 'curl',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'tool not found' },
      source: SOURCE
    });
  }

  if (hits.length > 0) {
    const p = writeEvidence(evDir, `${target}.exposure-check.json`, JSON.stringify(hits, null, 2));
    emitJsonl(emit, {
      type: 'finding',
      tool: 'exposure-check',
      stage: STAGE,
      target,
      severity: 'low',
      evidence: [p],
      data: { hits },
      source: SOURCE
    });
  } else {
    emitJsonl(emit, {
      type: 'note',
      tool: 'exposure-check',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { message: 'no obvious exposures detected (safe checks only)' },
      source: SOURCE
    });
  }

  if (!exploitAllowed(allowExploit)) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'exploit-gate',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { intrusive_actions: 'blocked', required: '--allow-exploit + env CONFIRM=arrocha!' },
      source: SOURCE
    });
    return;
  }

  // Gated: run nuclei as a non-destructive PoC validation (template-driven, still intrusive).
  if (!which('nuclei')) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'nuclei',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'tool not found' },
      source: SOURCE
    });
    return;
  }

  const outJsonl = path.join(evDir, `${target}.nuclei.jsonl`);
  await runCmdCapture('bash', ['-lc', `timeout ${Math.max(maxSecs, 60)}s nuclei -target ${JSON.stringify(target)} -jsonl -silent -severity high,critical -o ${JSON.stringify(outJsonl)} 2>/dev/null || true`]);
  if (require('fs').existsSync(outJsonl) && require('fs').statSync(outJsonl).size > 0) {
    emitJsonl(emit, {
      type: 'finding',
      tool: 'nuclei',
      stage: STAGE,
      target,
      severity: 'high',
      evidence: [outJsonl],
      data: { message: 'nuclei reported potential high/critical issues (review evidence)' },
      source: SOURCE
    });
  } else {
    emitJsonl(emit, {
      type: 'note',
      tool: 'nuclei',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [outJsonl],
      data: { message: 'nuclei run completed; no high/critical results (or no output)' },
      source: SOURCE
    });
  }
}

function defaultEmit(record) {
  if (!record.ts) record.ts = new Date().toISOString();
  if (!record.timestamp) record.timestamp = record.ts;
  process.stdout.write(`${JSON.stringify(record)}\n`);
}

module.exports = { run };

if (require.main === module) {
  (async () => {
    const args = parseCommonArgs(process.argv.slice(2));
    if (!args.target) {
      process.stderr.write('Usage: --target <host> [--out-dir dir] [--scope-file file] [--timeout sec] [--allow-exploit]\n');
      process.exit(1);
    }
    await run({
      target: args.target,
      emit: defaultEmit,
      outDir: args.outDir,
      scopeFile: args.scopeFile,
      timeout: args.timeout,
      allowExploit: args.allowExploit,
      runTs: process.env.RUN_TS || ''
    });
  })().catch((e) => {
    process.stderr.write(`${e && e.stack ? e.stack : String(e)}\n`);
    process.exit(1);
  });
}
