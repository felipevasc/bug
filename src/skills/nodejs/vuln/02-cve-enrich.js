#!/usr/bin/env node
'use strict';

/**
 * @skill: nodejs/vuln/cve-enrich
 * @inputs: target[, out-dir, run-ts]
 * @outputs: note
 * @tools: fetch
 */

const fs = require('fs');
const path = require('path');
const {
  parseCommonArgs,
  emitJsonl,
  ensureDir,
  writeEvidence
} = require('../../../lib/skill-utils');

const STAGE = 'vuln';
const SOURCE = 'src/skills/nodejs/vuln/02-cve-enrich.js';
const CVE_API_BASE = 'https://cve.circl.lu/api/search';
const MAX_TECHNIQUES = 6;
const MAX_CVES_PER_TECH = 5;
const MIN_MED_CVSS = 4.0;
const ANSI_PATTERN = /\u001b\[[0-9;]*m/g;
const GENERIC_SLASH_PATTERN = /([A-Za-z][A-Za-z0-9 .\\-_+&]{1,50})\/([0-9]+(?:\.[0-9]+){0,3})/;
const NAME_VERSION_PATTERN = /([A-Za-z][A-Za-z0-9 .\\-_+&]{1,60})\s+([0-9]+(?:\.[0-9]+){0,3})/;
const GENERATOR_PATTERN = /MetaGenerator\[([^\]]+)\]/;
const SEVERITY_ORDER = ['info', 'low', 'med', 'high'];

const SPECIAL_NAME_PATTERNS = [
  { regex: /Drupal\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Drupal', product: 'Drupal' },
  { regex: /WordPress\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'WordPress', product: 'WordPress' },
  { regex: /Joomla!?\.?\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Joomla', product: 'Joomla' },
  { regex: /TYPO3\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'TYPO3', product: 'TYPO3' },
  { regex: /Magento\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Magento', product: 'Magento' }
];

const CVE_ALIAS_MAP = [
  { regex: /apache/i, slug: { vendor: 'apache', product: 'httpd' } },
  { regex: /drupal/i, slug: { vendor: 'drupal', product: 'drupal' } },
  { regex: /wordpress/i, slug: { vendor: 'wordpress', product: 'wordpress' } },
  { regex: /joomla/i, slug: { vendor: 'joomla', product: 'joomla' } },
  { regex: /magento/i, slug: { vendor: 'magento', product: 'magento' } },
  { regex: /nginx/i, slug: { vendor: 'nginx', product: 'nginx' } },
  { regex: /cloudflare/i, slug: { vendor: 'cloudflare', product: 'cloudflare' } },
  { regex: /microsoft.*iis|iis/i, slug: { vendor: 'microsoft', product: 'iis' } },
  { regex: /tomcat/i, slug: { vendor: 'apache', product: 'tomcat' } },
  { regex: /jetty/i, slug: { vendor: 'eclipse', product: 'jetty' } }
];

function stripAnsi(value) {
  return String(value || '').replace(ANSI_PATTERN, '').trim();
}

function parseNameVersion(text) {
  const cleaned = stripAnsi(text);
  const match = NAME_VERSION_PATTERN.exec(cleaned);
  if (!match) return null;
  return { name: match[1].trim(), version: match[2].trim() };
}

function registerTechnology(store, entry) {
  const vendor = (entry.vendor || entry.product || entry.name || '').trim();
  const product = (entry.product || entry.vendor || entry.name || '').trim();
  if (!vendor && !product) return;
  const normalizedVendor = vendor || product;
  const normalizedProduct = product || vendor || normalizedVendor;
  const version = entry.version ? String(entry.version).trim() : '';
  const key = `${normalizedVendor.toLowerCase()}|${normalizedProduct.toLowerCase()}|${version}`;
  if (!store.has(key)) {
    store.set(key, {
      vendor: normalizedVendor,
      product: normalizedProduct,
      version: version || null,
      detail: entry.detail || null,
      sources: new Set()
    });
  }
  const target = store.get(key);
  target.sources.add(entry.source || 'cve-enrich');
}

function parseHeaders(headers, source, register) {
  if (!headers || typeof headers !== 'object') return;
  Object.entries(headers).forEach(([key, rawValue]) => {
    const values = Array.isArray(rawValue) ? rawValue : [rawValue];
    values.forEach((value) => {
      if (value === undefined || value === null) return;
      const cleaned = stripAnsi(value);
      if (!cleaned) return;
      if (/^server$/i.test(key)) {
        register({ vendor: cleaned, product: cleaned, detail: 'server header', source });
        return;
      }
      if (/^(x-)?generator$/i.test(key)) {
        const parsed = parseNameVersion(cleaned);
        if (parsed) {
          register({
            vendor: parsed.name,
            product: parsed.name,
            version: parsed.version,
            detail: key,
            source
          });
        } else {
          register({ vendor: cleaned, product: cleaned, detail: key, source });
        }
      }
    });
  });
}

function parseFingerprint(fingerprint, source, register) {
  const cleaned = stripAnsi(fingerprint);
  if (!cleaned) return;

  SPECIAL_NAME_PATTERNS.forEach((pattern) => {
    const regex = new RegExp(pattern.regex.source, 'gi');
    let match;
    while ((match = regex.exec(cleaned))) {
      register({
        vendor: pattern.vendor,
        product: pattern.product,
        version: match[1],
        detail: match[0],
        source
      });
    }
  });

  const generatorRegex = new RegExp(GENERATOR_PATTERN.source, 'gi');
  let generatorMatch;
  while ((generatorMatch = generatorRegex.exec(cleaned))) {
    const parsed = parseNameVersion(generatorMatch[1]);
    if (parsed) {
      register({
        vendor: parsed.name,
        product: parsed.name,
        version: parsed.version,
        detail: generatorMatch[1],
        source
      });
    }
  }

  const generalRegex = new RegExp(GENERIC_SLASH_PATTERN.source, 'g');
  let slashMatch;
  while ((slashMatch = generalRegex.exec(cleaned))) {
    register({
      vendor: slashMatch[1],
      product: slashMatch[1],
      version: slashMatch[2],
      detail: slashMatch[0],
      source
    });
  }
}

function gatherTechnologies(records) {
  const store = new Map();
  const register = (entry) => registerTechnology(store, entry);
  records.forEach((record) => {
    if (!record || !record.data) return;
    const source = record.tool || record.source || 'records';
    if (typeof record.data.server === 'string' && record.data.server) {
      register({ vendor: record.data.server, product: record.data.server, detail: 'server header', source });
    }
    parseHeaders(record.data.headers, source, register);
    if (typeof record.data.fingerprint === 'string') {
      parseFingerprint(record.data.fingerprint, source, register);
    }
  });

  const techs = Array.from(store.values()).map((item) => ({
    vendor: item.vendor,
    product: item.product,
    version: item.version,
    detail: item.detail,
    sources: Array.from(item.sources)
  }));
  techs.sort((a, b) => {
    const aVersion = Boolean(a.version);
    const bVersion = Boolean(b.version);
    if (aVersion !== bVersion) return aVersion ? -1 : 1;
    return (a.vendor || '').localeCompare(b.vendor || '');
  });
  return techs;
}

function slugify(value) {
  const cleaned = String(value || '').toLowerCase();
  return cleaned.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'unknown';
}

function resolveCveSlug(tech) {
  const lookupStrings = [tech.vendor, tech.product, tech.detail].filter(Boolean).map((v) => v.toLowerCase());
  for (const text of lookupStrings) {
    for (const alias of CVE_ALIAS_MAP) {
      if (alias.regex.test(text)) {
        return alias.slug;
      }
    }
  }
  const vendorSlug = slugify(tech.vendor || tech.product || 'vendor');
  const productSlug = slugify(tech.product || tech.vendor || 'product');
  return { vendor: vendorSlug, product: productSlug };
}

function severityFromCvss(cvss) {
  if (cvss === null || cvss === undefined) return 'info';
  if (cvss >= 7) return 'high';
  if (cvss >= MIN_MED_CVSS) return 'med';
  if (cvss > 0) return 'low';
  return 'info';
}

function mergeSeverity(current, next) {
  const currentIdx = SEVERITY_ORDER.indexOf(current);
  const nextIdx = SEVERITY_ORDER.indexOf(next);
  if (currentIdx === -1) return next;
  if (nextIdx === -1) return current;
  return nextIdx > currentIdx ? next : current;
}

function normalizeCvss(value) {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : null;
}

function pickRelevantCves(results) {
  const normalized = (Array.isArray(results) ? results : []).map((item) => ({
    id: String(item.id || item.cve || '').trim(),
    cvss: normalizeCvss(item.cvss),
    summary: item.summary || item.Summary || '',
    published: item.Published || item.published || null,
    references: Array.isArray(item.references) ? item.references : []
  })).filter((entry) => entry.cvss !== null && entry.cvss >= MIN_MED_CVSS);
  normalized.sort((a, b) => (b.cvss || 0) - (a.cvss || 0));
  return normalized.slice(0, MAX_CVES_PER_TECH);
}

async function fetchCveResults(slug, cacheDir, cachePaths) {
  if (!slug.vendor || !slug.product) return { results: [] };
  const safeName = `${slug.vendor}-${slug.product}.json`;
  const cachePath = path.join(cacheDir, safeName);
  if (fs.existsSync(cachePath)) {
    try {
      const stored = JSON.parse(fs.readFileSync(cachePath, 'utf8'));
      cachePaths.add(cachePath);
      return stored;
    } catch (err) {
      console.error(`[cve-enrich] failed to read cache ${cachePath}: ${err.message || err}`);
    }
  }

  const url = `${CVE_API_BASE}/${encodeURIComponent(slug.vendor)}/${encodeURIComponent(slug.product)}`;
  let payload = { results: [] };
  try {
    const response = await fetch(url, { headers: { Accept: 'application/json' } });
    if (response.ok) {
      payload = await response.json();
    } else {
      console.error(`[cve-enrich] ${response.status} ${response.statusText} querying ${url}`);
    }
  } catch (err) {
    console.error(`[cve-enrich] fetch failed for ${url}: ${err && err.message ? err.message : err}`);
  }

  try {
    const persisted = writeEvidence(cacheDir, safeName, JSON.stringify(payload || { results: [] }, null, 2));
    cachePaths.add(persisted);
  } catch (err) {
    console.error(`[cve-enrich] unable to cache ${safeName}: ${err && err.message ? err.message : err}`);
  }
  return payload;
}

async function buildWatchlist(technologies, cacheDir) {
  const watchlist = [];
  const cachePaths = new Set();
  for (const tech of technologies.slice(0, MAX_TECHNIQUES)) {
    const slug = resolveCveSlug(tech);
    const payload = await fetchCveResults(slug, cacheDir, cachePaths);
    const cves = pickRelevantCves(payload.results || payload);
    if (!cves.length) continue;
    watchlist.push({
      technology: tech.product || tech.vendor || 'unknown technology',
      vendor: tech.vendor || null,
      product: tech.product || null,
      version: tech.version || null,
      sources: tech.sources || [],
      cves
    });
  }
  return { watchlist, cachePaths };
}

function readRecords(recordsPath) {
  if (!fs.existsSync(recordsPath)) return [];
  const raw = fs.readFileSync(recordsPath, 'utf8');
  return raw.split('\n').map((line) => line.trim()).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch (_err) {
      console.error(`[cve-enrich] failed to parse record line: ${line.substring(0, 120)}`);
      return null;
    }
  }).filter(Boolean);
}

async function run({ target, emit, outDir, runTs }) {
  const rootOut = outDir || process.env.OUT_DIR || path.resolve('data', 'runs', runTs || 'run');
  const recordsPath = path.join(rootOut, 'records.jsonl');
  const records = readRecords(recordsPath);

  if (!records.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'no records available for enrichment' },
      source: SOURCE
    });
    return;
  }

  const technologies = gatherTechnologies(records);
  if (!technologies.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'no fingerprinted technologies found' },
      source: SOURCE
    });
    return;
  }

  const safeTarget = slugify(target || runTs || 'default');
  const cacheDir = path.join(rootOut, 'evidence', 'vuln', 'cve-enrich', safeTarget);
  ensureDir(cacheDir);

  const { watchlist, cachePaths } = await buildWatchlist(technologies, cacheDir);
  if (!watchlist.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: Array.from(cachePaths),
      data: {
        watchlist: [],
        analyzed: technologies.slice(0, MAX_TECHNIQUES),
        note: 'No MED/HIGH CVEs (CVSS â‰¥ 4) were discovered for the discovered stack.'
      },
      source: SOURCE
    });
    return;
  }

  let highestSeverity = 'info';
  watchlist.forEach((entry) => {
    entry.cves.forEach((cve) => {
      highestSeverity = mergeSeverity(highestSeverity, severityFromCvss(cve.cvss));
    });
  });

  emitJsonl(emit, {
    type: 'note',
    tool: 'cve-enrich',
    stage: STAGE,
    target,
    severity: highestSeverity,
    evidence: Array.from(cachePaths),
    data: {
      watchlist,
      analyzed: technologies.slice(0, MAX_TECHNIQUES),
      context: 'CVE enrichment is a technology risk watchlist; treat the CVEs as candidates for manual verification.'
    },
    source: SOURCE
  });
}

module.exports = { run };

if (require.main === module) {
  const args = parseCommonArgs(process.argv.slice(2));
  const target = args.target || args.url || '';
  run({
    target,
    outDir: args.outDir,
    runTs: process.env.RUN_TS || '',
    emit: (rec) => process.stdout.write(`${JSON.stringify(rec)}\n`)
  }).catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
