#!/usr/bin/env node
'use strict';

/**
 * @skill: nodejs/vuln/cve-enrich
 * @inputs: target[, out-dir, run-ts]
 * @outputs: note
 * @tools: fetch
 */

const fs = require('fs');
const path = require('path');
const {
  parseCommonArgs,
  emitJsonl,
  ensureDir,
  writeEvidence
} = require('../../../lib/skill-utils');

const STAGE = 'vuln';
const SOURCE = 'src/skills/nodejs/vuln/02-cve-enrich.js';
const CVE_API_BASE = 'https://cve.circl.lu/api/search';
const MAX_TECHNIQUES = 6;
const MAX_CVES_PER_TECH = 5;
const MIN_MED_CVSS = 4.0;
const APACHE_HTTPD_PRODUCTS = ['http_server', 'httpd', 'apache_http_server'];
const DRUPAL_CORE_PRODUCTS = ['drupal', 'drupalcore', 'drupal-core'];
const ANSI_PATTERN = /\u001b\[[0-9;]*m/g;
const GENERIC_SLASH_PATTERN = /([A-Za-z][A-Za-z0-9 .\\-_+&]{1,50})\/([0-9]+(?:\.[0-9]+){0,3})/;
const NAME_VERSION_PATTERN = /([A-Za-z][A-Za-z0-9 .\\-_+&]{1,60})\s+([0-9]+(?:\.[0-9]+){0,3})/;
const GENERATOR_PATTERN = /MetaGenerator\[([^\]]+)\]/;
const SEVERITY_ORDER = ['info', 'low', 'med', 'high'];
const WATCHLIST_SEVERITY_ORDER = ['crit', 'high', 'med', 'low', 'info', 'unknown'];
const CVE_DETAIL_BASE = 'https://cve.circl.lu/api/cve';
const CVE_DETAIL_SUBDIR = 'cve';
const CVE_IMPACT_KEYWORDS = [
  { label: 'RCE', terms: ['remote code execution', 'remote command execution', 'arbitrary code execution', 'command execution', 'rce'] },
  { label: 'SQLi', terms: ['sql injection', 'sqli', 'database injection'] },
  { label: 'XSS', terms: ['cross-site scripting', 'xss', 'stored xss', 'reflected xss', 'dom-based xss'] },
  { label: 'SSRF', terms: ['server side request forgery', 'ssrf', 'server-side request forgery'] },
  { label: 'Auth bypass', terms: ['authentication bypass', 'auth bypass', 'bypass authentication', 'bypass authorization'] },
  { label: 'Info leak', terms: ['information disclosure', 'information leak', 'sensitive data', 'data leak', 'privacy compromise'] },
  { label: 'DoS', terms: ['denial of service', 'dos', 'service outage', 'resource exhaustion', 'kernel panic', 'crash'] },
  { label: 'Priv esc', terms: ['privilege escalation', 'privilege elevation', 'gain privileges', 'elevated privileges'] }
];
const CVE_EXPLOIT_PATTERNS = [
  new RegExp('exploit-db\\.org', 'i'),
  new RegExp('metasploit\\.com', 'i'),
  new RegExp('packetstormsecurity\\.com', 'i'),
  new RegExp('0day\\.today', 'i'),
  new RegExp('nuclei[-_]templates', 'i'),
  new RegExp('projectdiscovery\\/(nuclei|nuclei-templates)', 'i'),
  new RegExp('github\\.com\\/[^\\/]+\\/[^\\/]+\\/(poc|pocs|proof-of-concept|exploit)', 'i'),
  new RegExp('githubusercontent\\.com', 'i'),
  new RegExp('gitlab\\.com\\/[^\\/]+\\/[^\\/]+\\/(poc|exploit|proof-of-concept)', 'i')
];
const CVE_EXPLOIT_KEYWORDS = ['poc', 'proof-of-concept', 'proof of concept', 'public exploit', 'exploit available', 'weaponized', 'shellcode proof', 'exploit module'];
const CVE_FIX_PATTERNS = [
  /upgrade to (?:version )?([\d][\dA-Za-z.\-]*)/i,
  /update to (?:version )?([\d][\dA-Za-z.\-]*)/i,
  /fixed in (?:version )?([\d][\dA-Za-z.\-]*)/i,
  /patch(?: release)? (?:to )?([\d][\dA-Za-z.\-]*)/i
];
const CVE_FIX_RECOMMENDATION = /recommend(?:ed)? to upgrade to (?:version )?([\d][\dA-Za-z.\-]*)/i;

const DESCRIPTION_SUMMARY_LIMIT = 240;
const MAX_AFFECTED_LENGTH = 240;
const CVE_ONLINE_TIMEOUT_MS = 5000;
const ONLINE_ENABLED = !['0', 'false', 'no'].includes(String(process.env.CVE_ENRICH_ONLINE || '').toLowerCase());
const CVSS_IMPACT_SCORE = { H: 3, M: 2, L: 1, N: 0, P: 1 };
const CVSS_PRECONDITION_FIELDS = ['AV', 'AC', 'PR', 'UI', 'S'];
const VECTOR_IMPACT_PRIORITY = { 'Priv esc': 3, 'Info leak': 2, 'DoS': 1 };
const CWE_IMPACT_MAP = {
  '78': 'RCE',
  '94': 'RCE',
  '86': 'RCE',
  '89': 'SQLi',
  '90': 'SSRF',
  '918': 'SSRF',
  '79': 'XSS',
  '200': 'Info leak',
  '201': 'Info leak',
  '202': 'Info leak',
  '203': 'Info leak',
  '204': 'Info leak',
  '209': 'Info leak',
  '264': 'Priv esc',
  '269': 'Priv esc',
  '284': 'Auth bypass',
  '285': 'Auth bypass',
  '287': 'Auth bypass',
  '288': 'Auth bypass',
  '399': 'DoS',
  '400': 'DoS',
  '404': 'DoS'
};

const MAX_SUMMARY_LENGTH = 320;

const SPECIAL_NAME_PATTERNS = [
  { regex: /Drupal\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Drupal', product: 'Drupal' },
  { regex: /WordPress\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'WordPress', product: 'WordPress' },
  { regex: /Joomla!?\.?\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Joomla', product: 'Joomla' },
  { regex: /TYPO3\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'TYPO3', product: 'TYPO3' },
  { regex: /Magento\s+([0-9]+(?:\.[0-9]+)*)/i, vendor: 'Magento', product: 'Magento' }
];

const CVE_ALIAS_MAP = [
  { regex: /apache/i, slug: { vendor: 'apache', product: 'httpd' } },
  { regex: /drupal/i, slug: { vendor: 'drupal', product: 'drupal' } },
  { regex: /drupalcore/i, slug: { vendor: 'drupal', product: 'drupalcore' } },
  { regex: /wordpress/i, slug: { vendor: 'wordpress', product: 'wordpress' } },
  { regex: /joomla/i, slug: { vendor: 'joomla', product: 'joomla' } },
  { regex: /magento/i, slug: { vendor: 'magento', product: 'magento' } },
  { regex: /nginx/i, slug: { vendor: 'nginx', product: 'nginx' } },
  { regex: /cloudflare/i, slug: { vendor: 'cloudflare', product: 'cloudflare' } },
  { regex: /microsoft.*iis|iis/i, slug: { vendor: 'microsoft', product: 'iis' } },
  { regex: /tomcat/i, slug: { vendor: 'apache', product: 'tomcat' } },
  { regex: /jetty/i, slug: { vendor: 'eclipse', product: 'jetty' } }
];

function stripAnsi(value) {
  return String(value || '').replace(ANSI_PATTERN, '').trim();
}

function normalizeCvss(value) {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : null;
}

function severityFromCvss(cvss) {
  if (cvss === null || cvss === undefined) return 'unknown';
  const numeric = normalizeCvss(cvss);
  if (numeric === null) return 'unknown';
  if (numeric >= 9.0) return 'crit';
  if (numeric >= 7.0) return 'high';
  if (numeric >= MIN_MED_CVSS) return 'med';
  if (numeric > 0) return 'low';
  return 'info';
}

function mergeSeverity(current, next) {
  const order = WATCHLIST_SEVERITY_ORDER;
  const cur = String(current || 'unknown').toLowerCase();
  const nxt = String(next || 'unknown').toLowerCase();
  const curIdx = order.indexOf(cur);
  const nxtIdx = order.indexOf(nxt);
  if (curIdx === -1) return nxt;
  if (nxtIdx === -1) return cur;
  return nxtIdx < curIdx ? nxt : cur;
}

function parseNameVersion(text) {
  const cleaned = stripAnsi(text);
  const match = NAME_VERSION_PATTERN.exec(cleaned);
  if (!match) return null;
  return { name: match[1].trim(), version: match[2].trim() };
}

function registerTechnology(store, entry) {
  const vendor = (entry.vendor || entry.product || entry.name || '').trim();
  const product = (entry.product || entry.vendor || entry.name || '').trim();
  if (!vendor && !product) return;
  const normalizedVendor = vendor || product;
  const normalizedProduct = product || vendor || normalizedVendor;
  const version = entry.version ? String(entry.version).trim() : '';
  const key = `${normalizedVendor.toLowerCase()}|${normalizedProduct.toLowerCase()}|${version}`;
  if (!store.has(key)) {
    store.set(key, {
      vendor: normalizedVendor,
      product: normalizedProduct,
      version: version || null,
      detail: entry.detail || null,
      sources: new Set()
    });
  }
  const target = store.get(key);
  target.sources.add(entry.source || 'cve-enrich');
}

function parseHeaders(headers, source, register) {
  if (!headers || typeof headers !== 'object') return;
  Object.entries(headers).forEach(([key, rawValue]) => {
    const values = Array.isArray(rawValue) ? rawValue : [rawValue];
    values.forEach((value) => {
      if (value === undefined || value === null) return;
      const cleaned = stripAnsi(value);
      if (!cleaned) return;
      if (/^server$/i.test(key)) {
        register({ vendor: cleaned, product: cleaned, detail: 'server header', source });
        return;
      }
      if (/^(x-)?generator$/i.test(key)) {
        const parsed = parseNameVersion(cleaned);
        if (parsed) {
          register({
            vendor: parsed.name,
            product: parsed.name,
            version: parsed.version,
            detail: key,
            source
          });
        } else {
          register({ vendor: cleaned, product: cleaned, detail: key, source });
        }
      }
    });
  });
}

function parseFingerprint(fingerprint, source, register) {
  const cleaned = stripAnsi(fingerprint);
  if (!cleaned) return;

  SPECIAL_NAME_PATTERNS.forEach((pattern) => {
    const regex = new RegExp(pattern.regex.source, 'gi');
    let match;
    while ((match = regex.exec(cleaned))) {
      register({
        vendor: pattern.vendor,
        product: pattern.product,
        version: match[1],
        detail: match[0],
        source
      });
    }
  });

  const generatorRegex = new RegExp(GENERATOR_PATTERN.source, 'gi');
  let generatorMatch;
  while ((generatorMatch = generatorRegex.exec(cleaned))) {
    const parsed = parseNameVersion(generatorMatch[1]);
    if (parsed) {
      register({
        vendor: parsed.name,
        product: parsed.name,
        version: parsed.version,
        detail: generatorMatch[1],
        source
      });
    }
  }

  const generalRegex = new RegExp(GENERIC_SLASH_PATTERN.source, 'g');
  let slashMatch;
  while ((slashMatch = generalRegex.exec(cleaned))) {
    register({
      vendor: slashMatch[1],
      product: slashMatch[1],
      version: slashMatch[2],
      detail: slashMatch[0],
      source
    });
  }
}

function gatherTechnologies(records) {
  const store = new Map();
  const register = (entry) => registerTechnology(store, entry);
  records.forEach((record) => {
    if (!record || !record.data) return;
    const source = record.tool || record.source || 'records';
    if (typeof record.data.server === 'string' && record.data.server) {
      register({ vendor: record.data.server, product: record.data.server, detail: 'server header', source });
    }
    parseHeaders(record.data.headers, source, register);
    if (typeof record.data.fingerprint === 'string') {
      parseFingerprint(record.data.fingerprint, source, register);
    }
  });

  const techs = Array.from(store.values()).map((item) => ({
    vendor: item.vendor,
    product: item.product,
    version: item.version,
    detail: item.detail,
    sources: Array.from(item.sources)
  }));
  techs.sort((a, b) => {
    const aVersion = Boolean(a.version);
    const bVersion = Boolean(b.version);
    if (aVersion !== bVersion) return aVersion ? -1 : 1;
    return (a.vendor || '').localeCompare(b.vendor || '');
  });
  return techs;
}

function slugify(value) {
  const cleaned = String(value || '').toLowerCase();
  return cleaned.replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '') || 'unknown';
}

function resolveCveSlug(tech) {
  const lookupStrings = [tech.vendor, tech.product, tech.detail].filter(Boolean).map((v) => v.toLowerCase());
  for (const text of lookupStrings) {
    for (const alias of CVE_ALIAS_MAP) {
      if (alias.regex.test(text)) {
        return alias.slug;
      }
    }
  }
  const vendorSlug = slugify(tech.vendor || tech.product || 'vendor');
  const productSlug = slugify(tech.product || tech.vendor || 'product');
  return { vendor: vendorSlug, product: productSlug };
}

const WATCHLIST_APPLICABILITY_ORDER = { likely: 0, unknown: 1 };
const CVSS_PRIORITY = ['cvssV3_1', 'cvssV3_0', 'cvssV3', 'cvssV2', 'cvssV4_0'];

function buildSlugVariants(tech) {
  const base = resolveCveSlug(tech);
  const seen = new Set();
  const variants = [];
  const add = (slug) => {
    if (!slug || !slug.vendor || !slug.product) return;
    const key = `${slug.vendor}|${slug.product}`;
    if (seen.has(key)) return;
    seen.add(key);
    variants.push({ vendor: slug.vendor, product: slug.product });
  };
  add(base);
  if (base.vendor === 'apache') {
    APACHE_HTTPD_PRODUCTS.forEach((product) => add({ vendor: base.vendor, product }));
  }
  if (base.vendor === 'drupal') {
    DRUPAL_CORE_PRODUCTS.forEach((product) => add({ vendor: base.vendor, product }));
  }
  return variants;
}

function extractTechMajorVersion(tech) {
  const candidates = [tech.version, tech.detail];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const match = String(candidate).match(/([0-9]+)/);
    if (match && match[1]) return match[1];
  }
  return null;
}

function matchesTechKeywords(tech, text) {
  if (!text) return false;
  const normalized = String(text).toLowerCase();
  const terms = [tech.vendor, tech.product, tech.detail]
    .filter(Boolean)
    .map((term) => String(term).trim().toLowerCase());
  if (!terms.length) return true;
  return terms.some((keyword) => keyword && normalized.includes(keyword));
}

function versionStringMatchesMajor(entry = {}, major) {
  if (!major) return false;
  const pattern = new RegExp(`\\b${major}(?:\\.|x|$|[^0-9])`, 'i');
  const chunks = ['version', 'lessThanOrEqual', 'startIncluding', 'endIncluding'].map((key) => entry[key]);
  const text = chunks.filter(Boolean).join(' ').toLowerCase();
  return Boolean(text && pattern.test(text));
}

function determineApplicability(tech, entry, majorVersion) {
  if (!entry || !entry.containers || !entry.containers.cna) return 'unknown';
  if (!majorVersion) return 'unknown';
  const cna = entry.containers.cna;
  if (!Array.isArray(cna.affected) || cna.affected.length === 0) return 'unknown';
  for (const affected of cna.affected) {
    const metadata = `${affected.product || ''} ${affected.vendor || ''} ${affected.packageName || ''}`;
    if (!matchesTechKeywords(tech, metadata)) continue;
    if (!Array.isArray(affected.versions) || affected.versions.length === 0) return 'likely';
    if (affected.versions.some((ver) => versionStringMatchesMajor(ver, majorVersion))) return 'likely';
  }
  return 'unknown';
}

function findCvssMetricDetail(metric) {
  if (!metric || typeof metric !== 'object') return null;
  const collect = (candidate) => {
    if (candidate && candidate.baseScore !== undefined) {
      const normalized = normalizeCvss(candidate.baseScore);
      if (normalized !== null) {
        const vector = typeof candidate.vectorString === 'string'
          ? candidate.vectorString
          : (typeof candidate.vector === 'string' ? candidate.vector : null);
        return { score: normalized, vector };
      }
    }
    return null;
  };

  for (const versionKey of CVSS_PRIORITY) {
    const info = collect(metric[versionKey]);
    if (info) return info;
  }
  const cvssInfo = collect(metric.cvss);
  if (cvssInfo) return cvssInfo;
  return collect(metric);
}

function extractCvssMetricInfo(containers = {}) {
  if (containers && Array.isArray(containers.cna?.metrics)) {
    for (const metric of containers.cna.metrics) {
      const info = findCvssMetricDetail(metric);
      if (info) return info;
    }
  }
  if (Array.isArray(containers.adp)) {
    for (const adpEntry of containers.adp) {
      if (!Array.isArray(adpEntry.metrics)) continue;
      for (const metric of adpEntry.metrics) {
        const info = findCvssMetricDetail(metric);
        if (info) return info;
      }
    }
  }
  return null;
}

function extractCvssScore(containers = {}) {
  const info = extractCvssMetricInfo(containers);
  return info ? info.score : null;
}

function extractCvssVector(containers = {}) {
  const info = extractCvssMetricInfo(containers);
  return info ? info.vector : null;
}

function parseCvssVector(vectorString) {
  const segments = {};
  if (!vectorString) return segments;
  vectorString.split('/').forEach((segment) => {
    const [rawKey, rawValue] = (segment || '').split(':');
    const key = String(rawKey || '').trim().toUpperCase();
    const value = String(rawValue || '').trim().toUpperCase();
    if (!key || !value) return;
    segments[key] = value;
  });
  return segments;
}

function impactFromCvssVector(vectorString) {
  const metrics = parseCvssVector(vectorString);
  const dimensions = [
    { key: 'I', label: 'Priv esc' },
    { key: 'C', label: 'Info leak' },
    { key: 'A', label: 'DoS' }
  ];
  let best = null;
  let bestScore = -1;
  dimensions.forEach(({ key, label }) => {
    const value = metrics[key];
    const score = CVSS_IMPACT_SCORE[String(value || '').toUpperCase()] || 0;
    if (score === 0) return;
    const bestPriority = best ? VECTOR_IMPACT_PRIORITY[best] || 0 : -1;
    const currentPriority = VECTOR_IMPACT_PRIORITY[label] || 0;
    if (score > bestScore || (score === bestScore && currentPriority > bestPriority)) {
      best = label;
      bestScore = score;
    }
  });
  return best;
}

function buildCvssPreconditions(vectorString) {
  const parsed = parseCvssVector(vectorString);
  const values = CVSS_PRECONDITION_FIELDS
    .map((key) => (parsed[key] ? `${key}:${parsed[key]}` : null))
    .filter(Boolean);
  return values.length ? values.join(' ') : null;
}

function describeVersionRange(versionEntry = {}) {
  const tokens = [];
  const addToken = (label) => {
    if (label) tokens.push(label);
  };
  addToken(versionEntry.startIncluding ? `>=${versionEntry.startIncluding}` : null);
  addToken(versionEntry.endIncluding ? `<=${versionEntry.endIncluding}` : null);
  addToken(versionEntry.greaterThanOrEqual ? `>=${versionEntry.greaterThanOrEqual}` : null);
  addToken(versionEntry.greaterThan ? `>${versionEntry.greaterThan}` : null);
  addToken(versionEntry.lessThanOrEqual ? `<=${versionEntry.lessThanOrEqual}` : null);
  addToken(versionEntry.lessThan ? `<${versionEntry.lessThan}` : null);
  addToken(versionEntry.version ? String(versionEntry.version) : null);
  return Array.from(new Set(tokens)).join(', ') || null;
}

function buildAffectedString(containers = {}) {
  const affected = containers.cna?.affected;
  if (!Array.isArray(affected) || !affected.length) return '';
  const parts = affected.map((entry) => {
    const label = entry.product || entry.packageName || entry.vendor || 'Affected product';
    const versionChunks = Array.isArray(entry.versions)
      ? entry.versions.map((ver) => describeVersionRange(ver)).filter(Boolean)
      : [];
    const versionText = versionChunks.length
      ? ` (${Array.from(new Set(versionChunks)).join(', ')})`
      : '';
    return `${label}${versionText}`;
  }).filter(Boolean);
  if (!parts.length) return '';
  const display = parts.slice(0, 3);
  let result = display.join('; ');
  if (parts.length > 3) {
    result = `${result}; +${parts.length - 3} more`;
  }
  if (result.length > MAX_AFFECTED_LENGTH) {
    return `${result.slice(0, MAX_AFFECTED_LENGTH - 3).trim()}...`;
  }
  return result;
}

function determineFixHint(containers = {}, description = '', affected = '') {
  const timeline = Array.isArray(containers.cna?.timeline) ? containers.cna.timeline : [];
  const timelineText = timeline
    .map((item) => (item && item.value ? item.value : ''))
    .filter(Boolean)
    .join(' ');
  const searchText = `${stripAnsi(description || '')} ${timelineText}`.trim();
  const fixPatterns = [...CVE_FIX_PATTERNS, CVE_FIX_RECOMMENDATION].filter(Boolean);
  for (const pattern of fixPatterns) {
    const match = pattern.exec(searchText);
    if (match && match[1]) {
      const cleaned = match[1].replace(/[.,;]+$/, '').trim();
      if (cleaned) return `Upgrade to ${cleaned} or later`;
    }
  }
  for (const item of timeline) {
    if (!item || !item.value) continue;
    const match = /fixed.*?([\d][\dA-Za-z.\-]*)/i.exec(item.value);
    if (match && match[1]) return `Fix referenced for ${match[1]}`;
  }
  const bounds = [];
  if (Array.isArray(containers.cna?.affected)) {
    containers.cna.affected.forEach((entry) => {
      if (!Array.isArray(entry.versions)) return;
      entry.versions.forEach((versionEntry) => {
        const bound = versionEntry.lessThan || versionEntry.lessThanOrEqual || versionEntry.endIncluding;
        if (bound) bounds.push(bound);
      });
    });
  }
  if (bounds.length) {
    const unique = Array.from(new Set(bounds));
    return `Upgrade beyond ${unique[0]}`;
  }
  if (affected) return `Follow vendor guidance for ${affected}`;
  return null;
}

function buildShortSummary(entry = {}) {
  const containers = entry.containers || {};
  const title = stripAnsi(containers.cna?.title || entry.title || '');
  const description = findEnglishDescription(containers) || entry.description || '';
  const cleanedDescription = description ? stripAnsi(description).replace(/\s+/g, ' ').trim() : '';
  const snippet = cleanedDescription
    ? `${cleanedDescription.slice(0, DESCRIPTION_SUMMARY_LIMIT)}${cleanedDescription.length > DESCRIPTION_SUMMARY_LIMIT ? '...' : ''}`
    : '';
  let sentence = '';
  if (title && snippet) {
    sentence = `${title} â€” ${snippet}`;
  } else if (title) {
    sentence = title;
  } else if (snippet) {
    sentence = snippet;
  } else if (entry.cveId) {
    sentence = `${entry.cveId} lacks a published title or description.`;
  } else {
    sentence = 'Summary unavailable.';
  }
  const tailParts = [];
  if (entry.affected) tailParts.push(`Impacts ${entry.affected}`);
  if (entry.fixedVersionOrMitigation) tailParts.push(`Remediation: ${entry.fixedVersionOrMitigation}`);
  const tail = tailParts.length ? ` ${tailParts.join('; ')}.` : '';
  const summary = `${sentence}${tail}`.trim();
  if (summary.length <= MAX_SUMMARY_LENGTH) return summary;
  return `${summary.slice(0, MAX_SUMMARY_LENGTH - 3).trim()}...`;
}

function applyOfflineEnrichments(entry) {
  if (!entry) return;
  entry.affected = buildAffectedString(entry.containers);
  entry.fixedVersionOrMitigation = determineFixHint(entry.containers, entry.description, entry.affected);
  const vectorSource = entry.vectorString || extractCvssVector(entry.containers);
  entry.preconditions = buildCvssPreconditions(vectorSource);
  entry.shortSummary = buildShortSummary(entry);
  entry.impact = inferImpact(entry);
  entry.exploitReferences = filterExploitReferences(entry.references || []);
  entry.exploitSignal = entry.exploitReferences.length > 0;
}

function inferImpact(entry = {}) {
  const containers = entry.containers || {};
  const descriptiveText = [
    entry.title,
    entry.description,
    findEnglishDescription(containers)
  ].filter(Boolean).join(' ').toLowerCase();
  const problemTypes = Array.isArray(entry.problemTypes)
    ? entry.problemTypes
    : containers.cna?.problemTypes || [];
  const impactFromProblemType = () => {
    if (!Array.isArray(problemTypes)) return null;
    for (const problem of problemTypes) {
      if (!problem || !Array.isArray(problem.descriptions)) continue;
      for (const desc of problem.descriptions) {
        if (!desc) continue;
        const rawCwe = String(desc.cweId || '').trim();
        if (!rawCwe) continue;
        const numeric = rawCwe.replace(/CWE-/i, '').replace(/[^0-9]/g, '');
        if (!numeric) continue;
        const label = CWE_IMPACT_MAP[numeric];
        if (label) return label;
      }
    }
    return null;
  };
  const cweImpact = impactFromProblemType();
  if (cweImpact) return cweImpact;
  for (const impactEntry of CVE_IMPACT_KEYWORDS) {
    if (impactEntry.terms.some((term) => descriptiveText.includes(term))) {
      return impactEntry.label;
    }
  }
  const vectorString = entry.vectorString || extractCvssVector(containers);
  const vectorImpact = impactFromCvssVector(vectorString);
  return vectorImpact || 'Other';
}

function filterExploitReferences(references = []) {
  if (!Array.isArray(references)) return [];
  const seen = new Set();
  const filtered = [];
  references.forEach((ref) => {
    if (!ref) return;
    const raw = String(ref).trim();
    if (!raw) return;
    const lower = raw.toLowerCase();
    if (seen.has(lower)) return;
    const matchesPattern = CVE_EXPLOIT_PATTERNS.some((pattern) => pattern.test(raw));
    const matchesKeyword = CVE_EXPLOIT_KEYWORDS.some((term) => lower.includes(term));
    if (matchesPattern || matchesKeyword) {
      seen.add(lower);
      filtered.push(raw);
    }
  });
  return filtered;
}

function mergeReferences(base = [], extras = []) {
  const seen = new Set();
  const add = (value) => {
    if (!value) return;
    const normalized = String(value).trim();
    if (normalized) seen.add(normalized);
  };
  (base || []).forEach(add);
  (extras || []).forEach(add);
  return Array.from(seen);
}

function gatherReferences(containers = {}, extras = []) {
  const refs = new Set();
  const addRef = (item) => {
    if (!item) return;
    if (typeof item === 'string') {
      refs.add(item);
    } else if (item.url) {
      refs.add(item.url);
    }
  };
  const addList = (list) => {
    if (!Array.isArray(list)) return;
    list.forEach(addRef);
  };
  addList(containers.cna?.references);
  addList(extras);
  if (Array.isArray(containers.cna?.affected)) {
    containers.cna.affected.forEach((aff) => {
      addRef(aff.collectionURL);
    });
  }
  return Array.from(refs);
}

function findEnglishDescription(containers = {}) {
  const descriptions = containers.cna?.descriptions;
  if (!Array.isArray(descriptions)) return '';
  const english = descriptions.find((d) => d && String(d.lang || '').toLowerCase() === 'en' && d.value);
  if (english && english.value) return stripAnsi(english.value);
  const first = descriptions.find((d) => d && d.value);
  return first ? stripAnsi(first.value) : '';
}

function normalizeCveEntry(id, data, sourceLabel) {
  if (!data || typeof data !== 'object') return null;
  const payload = data;
  const cveMeta = payload.cveMetadata || payload.CVE || payload.CVE_metadata || null;
  const candidateId = String((cveMeta && cveMeta.cveId) || payload.cveId || payload.id || payload.cve || id || '').toUpperCase().trim();
  if (!candidateId) return null;
  const containers = payload.containers || {};
  const title = stripAnsi((containers.cna && containers.cna.title) || payload.title || payload.summary || candidateId);
  const description = findEnglishDescription(containers) || payload.summary || '';
  const published = (containers.cna && containers.cna.datePublic)
    || (cveMeta && (cveMeta.datePublished || cveMeta.datePublic))
    || payload.Published
    || payload.published
    || null;
  const cvssInfo = extractCvssMetricInfo(containers);
  const score = cvssInfo ? cvssInfo.score : null;
  const severityBand = score !== null ? severityFromCvss(score) : 'unknown';
  const vectorString = cvssInfo ? cvssInfo.vector : null;
  const references = gatherReferences(containers, payload.references || []);
  const problemTypes = containers.cna?.problemTypes || payload.problemTypes || [];
  const entry = {
    cveId: candidateId,
    title,
    description,
    published,
    references,
    score,
    severityBand,
    containers,
    vectorString,
    problemTypes,
    sources: sourceLabel ? [sourceLabel] : [],
    preconditions: null,
    affected: null,
    fixedVersionOrMitigation: null,
    shortSummary: null,
    impact: null,
    exploitReferences: [],
    exploitSignal: false
  };
  applyOfflineEnrichments(entry);
  return entry;
}

function visitPayloadChunk(chunk, sourceLabel, entries) {
  if (!chunk) return;
  if (Array.isArray(chunk)) {
    chunk.forEach((item) => {
      if (Array.isArray(item) && item.length >= 2) {
        const normalized = normalizeCveEntry(item[0], item[1], sourceLabel);
        if (normalized) entries.push(normalized);
        return;
      }
      if (item && typeof item === 'object') {
        const normalized = normalizeCveEntry(item.cve || item.id || item.cveId, item, sourceLabel);
        if (normalized) entries.push(normalized);
      }
    });
    return;
  }
  if (chunk && typeof chunk === 'object') {
    const normalized = normalizeCveEntry(chunk.cve || chunk.id || chunk.cveId, chunk, sourceLabel);
    if (normalized) entries.push(normalized);
  }
}

function flattenCvePayload(payload) {
  const entries = [];
  if (!payload) return entries;
  if (Array.isArray(payload)) {
    visitPayloadChunk(payload, 'circl.archive', entries);
    return entries;
  }
  const root = payload.results || payload;
  if (Array.isArray(root)) {
    visitPayloadChunk(root, 'circl.search', entries);
    return entries;
  }
  if (root && typeof root === 'object') {
    Object.entries(root).forEach(([namespace, chunk]) => {
      const label = namespace ? `circl.${namespace.toLowerCase()}` : 'circl';
      visitPayloadChunk(chunk, label, entries);
    });
  }
  return entries;
}

function watchlistSeverityRank(severity) {
  const idx = WATCHLIST_SEVERITY_ORDER.indexOf(String(severity || 'unknown').toLowerCase());
  return idx === -1 ? WATCHLIST_SEVERITY_ORDER.length : idx;
}

function watchlistSorter(a, b) {
  const aApplicability = WATCHLIST_APPLICABILITY_ORDER[a.applicability] ?? WATCHLIST_APPLICABILITY_ORDER.unknown;
  const bApplicability = WATCHLIST_APPLICABILITY_ORDER[b.applicability] ?? WATCHLIST_APPLICABILITY_ORDER.unknown;
  if (aApplicability !== bApplicability) return aApplicability - bApplicability;

  const aSeverity = watchlistSeverityRank(a.severityBand);
  const bSeverity = watchlistSeverityRank(b.severityBand);
  if (aSeverity !== bSeverity) return aSeverity - bSeverity;

  const aScore = a.score !== null && a.score !== undefined ? a.score : -1;
  const bScore = b.score !== null && b.score !== undefined ? b.score : -1;
  if (aScore !== bScore) return bScore - aScore;

  if (a.published && b.published) {
    const cmp = b.published.localeCompare(a.published);
    if (cmp !== 0) return cmp;
  }

  return a.cveId.localeCompare(b.cveId);
}

function selectTopEntriesForTech(tech, records) {
  const dedup = new Map();
  records.forEach((entry) => {
    if (!entry || !entry.cveId) return;
    const key = [
      entry.cveId,
      tech.vendor,
      tech.product,
      tech.version,
      tech.detail
    ].map((value) => String(value || '').trim().toLowerCase()).join('|');
    const existing = dedup.get(key);
    if (!existing) {
      dedup.set(key, entry);
      return;
    }
    const existingScore = existing.score !== null && existing.score !== undefined ? existing.score : -1;
    const candidateScore = entry.score !== null && entry.score !== undefined ? entry.score : -1;
    if (candidateScore > existingScore) dedup.set(key, entry);
  });
  const majorVersion = extractTechMajorVersion(tech);
  const top = Array.from(dedup.values()).map((entry) => ({
    ...entry,
    tech: {
      vendor: tech.vendor || null,
      product: tech.product || null,
      version: tech.version || null,
      detail: tech.detail || null,
      sources: Array.isArray(tech.sources) ? tech.sources : []
    },
    applicability: determineApplicability(tech, entry, majorVersion)
  }));
  top.sort(watchlistSorter);
  return top.slice(0, MAX_CVES_PER_TECH);
}

async function fetchCveResults(slug, cacheDir, cachePaths) {
  if (!slug.vendor || !slug.product) return { results: [] };
  const safeName = `${slug.vendor}-${slug.product}.json`;
  const cachePath = path.join(cacheDir, safeName);
  if (fs.existsSync(cachePath)) {
    try {
      const stored = JSON.parse(fs.readFileSync(cachePath, 'utf8'));
      cachePaths.add(cachePath);
      return stored;
    } catch (err) {
      console.error(`[cve-enrich] failed to read cache ${cachePath}: ${err.message || err}`);
    }
  }

  const url = `${CVE_API_BASE}/${encodeURIComponent(slug.vendor)}/${encodeURIComponent(slug.product)}`;
  let payload = { results: [] };
  try {
    const response = await fetch(url, { headers: { Accept: 'application/json' } });
    if (response.ok) {
      payload = await response.json();
    } else {
      console.error(`[cve-enrich] ${response.status} ${response.statusText} querying ${url}`);
    }
  } catch (err) {
    console.error(`[cve-enrich] fetch failed for ${url}: ${err && err.message ? err.message : err}`);
  }

  try {
    const persisted = writeEvidence(cacheDir, safeName, JSON.stringify(payload || { results: [] }, null, 2));
    cachePaths.add(persisted);
  } catch (err) {
    console.error(`[cve-enrich] unable to cache ${safeName}: ${err && err.message ? err.message : err}`);
  }
  return payload;
}

async function fetchJsonWithTimeout(url, timeoutMs) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const response = await fetch(url, {
      headers: { Accept: 'application/json' },
      signal: controller.signal
    });
    if (!response.ok) throw new Error(`${response.status} ${response.statusText}`);
    return await response.json();
  } finally {
    clearTimeout(timer);
  }
}

async function fetchCveDetailRecord(cveId, detailDir, cachePaths, detailCache) {
  if (!cveId) return null;
  if (detailCache.has(cveId)) return detailCache.get(cveId);
  ensureDir(detailDir);
  const fileName = `${cveId}.json`;
  const filePath = path.join(detailDir, fileName);
  if (fs.existsSync(filePath)) {
    try {
      const stored = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      cachePaths.add(filePath);
      detailCache.set(cveId, stored);
      return stored;
    } catch (err) {
      console.error(`[cve-enrich] failed to read CVE detail cache ${filePath}: ${err.message || err}`);
    }
  }

  if (!ONLINE_ENABLED) {
    detailCache.set(cveId, null);
    return null;
  }

  const url = `${CVE_DETAIL_BASE}/${encodeURIComponent(cveId)}`;
  let payload = null;
  try {
    payload = await fetchJsonWithTimeout(url, CVE_ONLINE_TIMEOUT_MS);
  } catch (err) {
    console.error(`[cve-enrich] ${err && err.message ? err.message : err} fetching detail for ${cveId}`);
  }

  if (payload && typeof payload === 'object') {
    try {
      const persisted = writeEvidence(detailDir, fileName, JSON.stringify(payload, null, 2));
      cachePaths.add(persisted);
    } catch (err) {
      console.error(`[cve-enrich] unable to cache ${cveId} detail: ${err && err.message ? err.message : err}`);
    }
  }
  detailCache.set(cveId, payload);
  return payload;
}

async function enrichWatchlistEntry(entry, detailDir, cachePaths, detailCache) {
  if (!entry || !entry.cveId) return;
  const detail = await fetchCveDetailRecord(entry.cveId, detailDir, cachePaths, detailCache);
  if (detail && typeof detail === 'object' && Object.keys(detail).length) {
    if (detail.containers && Object.keys(detail.containers).length) {
      entry.containers = {
        ...entry.containers,
        ...detail.containers
      };
    }
    const detailTitle = detail.containers?.cna?.title || detail.title;
    if (detailTitle) entry.title = stripAnsi(detailTitle);
    const detailDescription = findEnglishDescription(detail.containers || {}) || detail.summary || '';
    if (detailDescription) entry.description = detailDescription;
    const detailCvss = extractCvssMetricInfo(entry.containers);
    entry.score = detailCvss?.score ?? entry.score;
    entry.vectorString = detailCvss?.vector ?? entry.vectorString;
    entry.severityBand = entry.score !== null ? severityFromCvss(entry.score) : entry.severityBand || 'unknown';
    entry.sources = Array.from(new Set([...(entry.sources || []), 'circl.detail']));
    const detailReferences = Array.isArray(detail.references) ? detail.references : [];
    entry.references = mergeReferences(entry.references, detailReferences);
  }
  applyOfflineEnrichments(entry);
}

async function enrichWatchlistEntries(entries, detailDir, cachePaths) {
  if (!Array.isArray(entries) || !entries.length) return;
  const detailCache = new Map();
  for (const entry of entries) {
    await enrichWatchlistEntry(entry, detailDir, cachePaths, detailCache);
  }
}

async function buildWatchlist(technologies, cacheDir) {
  const watchlist = [];
  const cachePaths = new Set();
  for (const tech of technologies.slice(0, MAX_TECHNIQUES)) {
    const entries = [];
    const slugVariants = buildSlugVariants(tech);
    for (const slug of slugVariants) {
      const payload = await fetchCveResults(slug, cacheDir, cachePaths);
      entries.push(...flattenCvePayload(payload));
    }
    if (!entries.length) continue;
    const topEntries = selectTopEntriesForTech(tech, entries);
    if (!topEntries.length) continue;
    watchlist.push(...topEntries);
  }
  const detailDir = path.join(cacheDir, CVE_DETAIL_SUBDIR);
  ensureDir(detailDir);
  await enrichWatchlistEntries(watchlist, detailDir, cachePaths);
  return { watchlist, cachePaths };
}

function readRecords(recordsPath) {
  if (!fs.existsSync(recordsPath)) return [];
  const raw = fs.readFileSync(recordsPath, 'utf8');
  return raw.split('\n').map((line) => line.trim()).filter(Boolean).map((line) => {
    try {
      return JSON.parse(line);
    } catch (_err) {
      console.error(`[cve-enrich] failed to parse record line: ${line.substring(0, 120)}`);
      return null;
    }
  }).filter(Boolean);
}

async function run({ target, emit, outDir, runTs }) {
  const rootOut = outDir || process.env.OUT_DIR || path.resolve('data', 'runs', runTs || 'run');
  const recordsPath = path.join(rootOut, 'records.jsonl');
  const records = readRecords(recordsPath);

  if (!records.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'no records available for enrichment' },
      source: SOURCE
    });
    return;
  }

  const technologies = gatherTechnologies(records);
  if (!technologies.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: [],
      data: { skipped: true, reason: 'no fingerprinted technologies found' },
      source: SOURCE
    });
    return;
  }

  const safeTarget = slugify(target || runTs || 'default');
  const cacheDir = path.join(rootOut, 'evidence', 'vuln', 'cve-enrich', safeTarget);
  ensureDir(cacheDir);

  const { watchlist, cachePaths } = await buildWatchlist(technologies, cacheDir);
  const analyzed = technologies.slice(0, MAX_TECHNIQUES);
  const context = 'CVE enrichment is a technology risk watchlist; treat the CVEs as candidates for manual verification.';
  if (!watchlist.length) {
    emitJsonl(emit, {
      type: 'note',
      tool: 'cve-enrich',
      stage: STAGE,
      target,
      severity: 'info',
      evidence: Array.from(cachePaths),
      data: {
        watchlist: [],
        watchlistCount: 0,
        analyzed,
        context,
        note: 'No candidate CVEs were discovered for the current stack.'
      },
      source: SOURCE
    });
    return;
  }

  let highestSeverity = 'info';
  watchlist.forEach((entry) => {
    highestSeverity = mergeSeverity(highestSeverity, severityFromCvss(entry.score));
  });

  emitJsonl(emit, {
    type: 'note',
    tool: 'cve-enrich',
    stage: STAGE,
    target,
    severity: highestSeverity,
    evidence: Array.from(cachePaths),
    data: {
      watchlist,
      watchlistCount: watchlist.length,
      analyzed,
      context,
      note: 'Version applicability is best-effort; verify the stack details before prioritizing.'
    },
    source: SOURCE
  });
}

module.exports = { run };

if (require.main === module) {
  const args = parseCommonArgs(process.argv.slice(2));
  const target = args.target || args.url || '';
  run({
    target,
    outDir: args.outDir,
    runTs: process.env.RUN_TS || '',
    emit: (rec) => process.stdout.write(`${JSON.stringify(rec)}\n`)
  }).catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
